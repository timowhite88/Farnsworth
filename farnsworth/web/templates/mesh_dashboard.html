<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FARNS Mesh Protocol v2.0 — Live Network</title>
    <meta name="description" content="Real-time visualization of the FARNS GPU-as-Identity mesh protocol. Proof-of-Inference, Latent Routing, Attestation Chains, Swarm Memory.">
    <meta name="theme-color" content="#a78bfa">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=DM+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #06060c;
            --bg-raised: #0a0a14;
            --surface: rgba(255,255,255,0.025);
            --surface-hover: rgba(255,255,255,0.05);
            --border: rgba(255,255,255,0.06);
            --border-bright: rgba(255,255,255,0.12);
            --text: #c8d0dc;
            --text-dim: #4a5568;
            --text-bright: #e8ecf4;
            --purple: #a78bfa;
            --purple-dim: rgba(167,139,250,0.15);
            --purple-glow: rgba(167,139,250,0.3);
            --cyan: #22d3ee;
            --cyan-dim: rgba(34,211,238,0.15);
            --cyan-glow: rgba(34,211,238,0.3);
            --green: #34d399;
            --green-dim: rgba(52,211,153,0.15);
            --amber: #fbbf24;
            --amber-dim: rgba(251,191,36,0.12);
            --red: #f87171;
            --red-dim: rgba(248,113,113,0.12);
            --pink: #f472b6;
            --radius: 12px;
            --mono: 'JetBrains Mono', monospace;
            --display: 'Chakra Petch', sans-serif;
            --body: 'DM Sans', sans-serif;
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: var(--body);
            background: var(--bg);
            color: var(--text);
            line-height: 1.55;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
        }

        /* ── Scanline overlay ── */
        .scanlines {
            position: fixed; inset: 0; z-index: 9999; pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.03) 2px,
                rgba(0,0,0,0.03) 4px
            );
        }

        /* ── Ambient background ── */
        .ambient {
            position: fixed; inset: 0; z-index: 0; pointer-events: none;
            overflow: hidden;
        }
        .ambient::before {
            content: ''; position: absolute; top: -40%; left: -40%; width: 180%; height: 180%;
            background:
                radial-gradient(ellipse at 15% 30%, rgba(167,139,250,0.07) 0%, transparent 50%),
                radial-gradient(ellipse at 85% 25%, rgba(34,211,238,0.05) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 80%, rgba(52,211,153,0.03) 0%, transparent 40%);
            animation: ambientDrift 25s ease-in-out infinite alternate;
        }
        @keyframes ambientDrift {
            0% { transform: translate(0,0) scale(1); }
            100% { transform: translate(-3%,2%) scale(1.02); }
        }

        /* ── Top bar ── */
        .topbar {
            position: sticky; top: 0; z-index: 100;
            background: rgba(6,6,12,0.88); backdrop-filter: blur(24px);
            border-bottom: 1px solid var(--border);
            padding: 0 28px; height: 56px;
            display: flex; align-items: center; justify-content: space-between;
        }
        .topbar-brand {
            font-family: var(--display); font-weight: 700; font-size: 14px;
            letter-spacing: 5px; text-transform: uppercase;
            background: linear-gradient(135deg, var(--purple), var(--cyan));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .topbar-status {
            display: flex; align-items: center; gap: 16px; font-size: 12px;
        }
        .status-pill {
            display: flex; align-items: center; gap: 6px;
            padding: 4px 12px; border-radius: 20px;
            background: var(--surface); border: 1px solid var(--border);
            font-family: var(--mono); font-size: 11px; color: var(--text-dim);
        }
        .status-pill .dot {
            width: 6px; height: 6px; border-radius: 50%;
            background: var(--green); box-shadow: 0 0 6px var(--green);
            animation: pulse 2s ease-in-out infinite;
        }
        .status-pill.offline .dot { background: var(--red); box-shadow: 0 0 6px var(--red); }
        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
        .topbar-nav { display: flex; gap: 4px; }
        .topbar-nav a {
            text-decoration: none; color: var(--text-dim); font-size: 12px;
            padding: 6px 14px; border-radius: 8px; transition: all 0.2s;
            font-family: var(--display); font-weight: 500; letter-spacing: 1px;
        }
        .topbar-nav a:hover { color: var(--text); background: var(--surface-hover); }
        .topbar-nav a.active { color: var(--purple); background: var(--purple-dim); }

        /* ── Layout ── */
        .page { position: relative; z-index: 1; max-width: 1600px; margin: 0 auto; padding: 24px; }

        /* ── Section headers ── */
        .section-head {
            display: flex; align-items: center; gap: 10px;
            margin-bottom: 16px; padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        .section-head .icon {
            width: 28px; height: 28px; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 13px;
        }
        .section-head h2 {
            font-family: var(--display); font-size: 13px; font-weight: 600;
            letter-spacing: 3px; text-transform: uppercase; color: var(--text-bright);
        }
        .section-head .count {
            margin-left: auto; font-family: var(--mono); font-size: 11px;
            color: var(--text-dim); background: var(--surface);
            padding: 2px 10px; border-radius: 10px; border: 1px solid var(--border);
        }

        /* ── Card ── */
        .card {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 20px;
            transition: border-color 0.3s;
        }
        .card:hover { border-color: var(--border-bright); }

        /* ── Mesh Topology (Hero) ── */
        .mesh-hero {
            margin-bottom: 24px; border-radius: var(--radius);
            background: var(--surface); border: 1px solid var(--border);
            position: relative; overflow: hidden;
        }
        .mesh-hero-header {
            padding: 20px 24px 0; display: flex; align-items: center; justify-content: space-between;
        }
        .mesh-hero-header h2 {
            font-family: var(--display); font-size: 13px; font-weight: 600;
            letter-spacing: 3px; text-transform: uppercase; color: var(--text-bright);
        }
        .mesh-meta {
            display: flex; gap: 24px; font-family: var(--mono); font-size: 11px; color: var(--text-dim);
        }
        .mesh-meta span { display: flex; align-items: center; gap: 6px; }
        .mesh-meta .val { color: var(--text); }

        #meshCanvas {
            width: 100%; height: 520px; display: block;
            cursor: default;
        }

        /* ── Bot tooltip ── */
        .bot-tooltip {
            position: absolute; z-index: 50; pointer-events: none;
            background: rgba(6,6,12,0.94); backdrop-filter: blur(16px);
            border: 1px solid var(--border-bright); border-radius: 10px;
            padding: 12px 16px; min-width: 200px; max-width: 280px;
            opacity: 0; transition: opacity 0.2s; font-size: 11px;
        }
        .bot-tooltip.visible { opacity: 1; }
        .bot-tooltip .tt-name {
            font-family: var(--display); font-weight: 700; font-size: 13px;
            margin-bottom: 4px; display: flex; align-items: center; gap: 8px;
        }
        .bot-tooltip .tt-name .tt-orb {
            width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
        }
        .bot-tooltip .tt-provider {
            font-family: var(--mono); font-size: 10px; color: var(--cyan);
            margin-bottom: 6px;
        }
        .bot-tooltip .tt-personality {
            color: var(--text-dim); font-size: 10px; line-height: 1.5;
            margin-bottom: 6px;
        }
        .bot-tooltip .tt-specs {
            display: flex; flex-wrap: wrap; gap: 4px;
        }
        .bot-tooltip .tt-specs span {
            padding: 1px 7px; border-radius: 8px; font-size: 9px;
            font-family: var(--mono); background: var(--surface);
            border: 1px solid var(--border); color: var(--text-dim);
        }

        /* ── Discussion Feed ── */
        .discussion-section {
            margin-bottom: 24px;
        }
        .discussion-card {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 20px;
        }
        .discussion-header {
            display: flex; align-items: center; gap: 10px;
            margin-bottom: 14px; padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        .discussion-header .icon {
            width: 28px; height: 28px; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 13px; background: linear-gradient(135deg, var(--green-dim), var(--cyan-dim));
            color: var(--green);
        }
        .discussion-header h2 {
            font-family: var(--display); font-size: 13px; font-weight: 600;
            letter-spacing: 3px; text-transform: uppercase; color: var(--text-bright);
        }
        .discussion-header .discussion-controls {
            margin-left: auto; display: flex; align-items: center; gap: 10px;
        }
        .disc-status-badge {
            display: flex; align-items: center; gap: 6px;
            padding: 3px 10px; border-radius: 14px; font-family: var(--mono);
            font-size: 10px; letter-spacing: 0.5px;
        }
        .disc-status-badge.active {
            background: var(--green-dim); color: var(--green);
            border: 1px solid rgba(52,211,153,0.2);
        }
        .disc-status-badge.paused {
            background: var(--amber-dim); color: var(--amber);
            border: 1px solid rgba(251,191,36,0.2);
        }
        .disc-status-badge .sdot {
            width: 5px; height: 5px; border-radius: 50%;
        }
        .disc-status-badge.active .sdot { background: var(--green); box-shadow: 0 0 4px var(--green); }
        .disc-status-badge.paused .sdot { background: var(--amber); box-shadow: 0 0 4px var(--amber); }
        .disc-toggle-btn {
            padding: 4px 14px; border: 1px solid var(--border); border-radius: 8px;
            background: var(--surface); color: var(--text-dim); cursor: pointer;
            font-family: var(--display); font-size: 10px; font-weight: 600;
            letter-spacing: 1.5px; text-transform: uppercase; transition: all 0.2s;
        }
        .disc-toggle-btn:hover {
            border-color: var(--border-bright); color: var(--text); background: var(--surface-hover);
        }

        .discussion-topic {
            padding: 10px 14px; border-radius: 8px; margin-bottom: 14px;
            background: rgba(0,0,0,0.2); border: 1px solid var(--border);
        }
        .discussion-topic .topic-label {
            font-family: var(--mono); font-size: 9px; color: var(--text-dim);
            text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 4px;
        }
        .discussion-topic .topic-text {
            font-size: 13px; color: var(--text-bright); line-height: 1.5;
        }
        .discussion-meta {
            display: flex; gap: 16px; margin-bottom: 14px;
            font-family: var(--mono); font-size: 10px; color: var(--text-dim);
        }
        .discussion-meta .dm-val { color: var(--text); }

        .discussion-feed {
            max-height: 320px; overflow-y: auto;
            display: flex; flex-direction: column; gap: 2px;
        }
        .discussion-feed::-webkit-scrollbar { width: 3px; }
        .discussion-feed::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 4px; }
        .disc-msg {
            display: flex; gap: 10px; padding: 10px 12px;
            border-radius: 8px; transition: background 0.2s;
            animation: fadeSlideIn 0.4s ease;
        }
        .disc-msg:hover { background: rgba(255,255,255,0.015); }
        .disc-msg .msg-orb {
            width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0;
            display: flex; align-items: center; justify-content: center;
            font-family: var(--display); font-size: 10px; font-weight: 700;
            color: rgba(255,255,255,0.9); position: relative;
        }
        .disc-msg .msg-orb::after {
            content: ''; position: absolute; inset: -3px; border-radius: 50%;
            border: 1px solid; opacity: 0.2;
        }
        .disc-msg .msg-body { flex: 1; min-width: 0; }
        .disc-msg .msg-head {
            display: flex; align-items: center; gap: 8px; margin-bottom: 3px;
        }
        .disc-msg .msg-name {
            font-family: var(--display); font-size: 11px; font-weight: 600;
        }
        .disc-msg .msg-time {
            font-family: var(--mono); font-size: 9px; color: var(--text-dim);
        }
        .disc-msg .msg-content {
            font-size: 12px; color: var(--text); line-height: 1.5;
            display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .disc-empty {
            text-align: center; padding: 40px; color: var(--text-dim); font-size: 12px;
        }
        @keyframes orbBreathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.06); }
        }

        /* ── 3-column grid ── */
        .grid-3 {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;
            margin-bottom: 24px;
        }
        @media (max-width: 1100px) { .grid-3 { grid-template-columns: 1fr; } }

        /* ── Radar chart container ── */
        .radar-wrap {
            display: flex; align-items: center; justify-content: center;
            padding: 12px 0;
        }
        #radarCanvas { max-width: 280px; max-height: 280px; }

        /* ── Model heatmap ── */
        .heatmap { display: grid; grid-template-columns: repeat(7, 1fr); gap: 3px; margin-top: 12px; }
        .heatmap-label {
            font-family: var(--mono); font-size: 9px; color: var(--text-dim);
            text-align: center; padding: 3px 0; letter-spacing: 0.5px;
        }
        .heatmap-cell {
            aspect-ratio: 1; border-radius: 4px; position: relative;
            display: flex; align-items: center; justify-content: center;
            font-family: var(--mono); font-size: 9px; color: rgba(255,255,255,0.7);
            transition: transform 0.2s; cursor: default;
        }
        .heatmap-cell:hover { transform: scale(1.15); z-index: 2; }

        /* ── Route feed ── */
        .route-feed { max-height: 200px; overflow-y: auto; margin-top: 12px; }
        .route-feed::-webkit-scrollbar { width: 3px; }
        .route-feed::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 4px; }
        .route-item {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
            font-size: 11px; animation: fadeSlideIn 0.3s ease;
        }
        @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(-6px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .route-item .prompt {
            flex: 1; color: var(--text-dim); font-family: var(--mono);
            font-size: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .route-item .arrow { color: var(--text-dim); font-size: 10px; }
        .route-item .model { color: var(--cyan); font-family: var(--mono); font-weight: 500; font-size: 10px; }
        .route-item .conf {
            font-family: var(--mono); font-size: 10px; padding: 1px 6px;
            border-radius: 4px; min-width: 42px; text-align: center;
        }

        /* ── Stats row ── */
        .stats-row {
            display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px;
        }
        .stat-box {
            flex: 1; min-width: 80px; text-align: center;
            padding: 10px 8px; border-radius: 8px;
            background: rgba(255,255,255,0.015); border: 1px solid var(--border);
        }
        .stat-box .num {
            font-family: var(--display); font-size: 22px; font-weight: 700;
            color: var(--text-bright);
        }
        .stat-box .label {
            font-size: 9px; color: var(--text-dim); text-transform: uppercase;
            letter-spacing: 1.5px; margin-top: 2px;
        }

        /* ── PoI consensus bars ── */
        .poi-round {
            padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
        }
        .poi-round-header {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 11px; margin-bottom: 6px;
        }
        .poi-round-header .id { font-family: var(--mono); color: var(--text-dim); }
        .poi-round-header .status { font-family: var(--mono); font-size: 10px; }
        .poi-bar-bg {
            height: 6px; border-radius: 3px; background: rgba(255,255,255,0.04);
            overflow: hidden;
        }
        .poi-bar-fill {
            height: 100%; border-radius: 3px;
            transition: width 0.6s ease;
        }

        /* ── Proof list ── */
        .proof-list { margin-top: 12px; }
        .proof-item {
            padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
            font-size: 11px;
        }
        .proof-item .seal-hex {
            font-family: var(--mono); font-size: 10px; color: var(--green);
            background: var(--green-dim); padding: 1px 6px; border-radius: 4px;
            display: inline-block; margin-top: 3px;
        }

        /* ── Attestation chain ── */
        .chain-visual { position: relative; padding-left: 24px; }
        .chain-link {
            position: relative; padding: 10px 0 10px 16px;
            border-left: 2px solid var(--border);
        }
        .chain-link::before {
            content: ''; position: absolute; left: -6px; top: 14px;
            width: 10px; height: 10px; border-radius: 50%;
            background: var(--purple); border: 2px solid var(--bg);
            box-shadow: 0 0 8px var(--purple-glow);
        }
        .chain-link:last-child { border-left-color: transparent; }
        .chain-link .seal {
            font-family: var(--mono); font-size: 10px; color: var(--purple);
            word-break: break-all;
        }
        .chain-link .meta {
            font-size: 10px; color: var(--text-dim); margin-top: 2px;
        }
        .chain-link .meta span { margin-right: 12px; }

        .trust-scores { margin-top: 16px; }
        .trust-row {
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.03);
            font-size: 11px;
        }
        .trust-row .node-name { font-family: var(--mono); }
        .trust-bar-bg {
            width: 80px; height: 5px; border-radius: 3px;
            background: rgba(255,255,255,0.04); overflow: hidden; margin: 0 10px;
        }
        .trust-bar-fill { height: 100%; border-radius: 3px; background: var(--green); }
        .trust-score { font-family: var(--mono); font-size: 10px; color: var(--green); min-width: 36px; text-align: right; }

        /* ── Chain integrity badge ── */
        .integrity-badge {
            display: inline-flex; align-items: center; gap: 6px;
            padding: 4px 12px; border-radius: 20px; font-size: 11px;
            font-family: var(--mono); margin-bottom: 12px;
        }
        .integrity-badge.valid { background: var(--green-dim); color: var(--green); border: 1px solid rgba(52,211,153,0.2); }
        .integrity-badge.broken { background: var(--red-dim); color: var(--red); border: 1px solid rgba(248,113,113,0.2); }

        /* ── Crystals bottom section ── */
        .crystals-section { margin-bottom: 24px; }
        .crystal-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;
            margin-bottom: 16px;
        }
        @media (max-width: 800px) { .crystal-grid { grid-template-columns: repeat(2, 1fr); } }
        .crystal-stat {
            text-align: center; padding: 16px 12px; border-radius: var(--radius);
            border: 1px solid var(--border); position: relative; overflow: hidden;
        }
        .crystal-stat .gem {
            font-size: 24px; margin-bottom: 6px; display: block;
        }
        .crystal-stat .num {
            font-family: var(--display); font-size: 28px; font-weight: 700;
        }
        .crystal-stat .label {
            font-size: 10px; color: var(--text-dim); text-transform: uppercase;
            letter-spacing: 1.5px; margin-top: 2px;
        }
        .crystal-stat.proposed { background: var(--amber-dim); }
        .crystal-stat.proposed .num { color: var(--amber); }
        .crystal-stat.voting { background: var(--cyan-dim); }
        .crystal-stat.voting .num { color: var(--cyan); }
        .crystal-stat.crystallized { background: var(--green-dim); }
        .crystal-stat.crystallized .num { color: var(--green); }
        .crystal-stat.rejected { background: var(--red-dim); }
        .crystal-stat.rejected .num { color: var(--red); }

        .crystal-list { margin-top: 12px; }
        .crystal-item {
            padding: 10px 14px; border-radius: 8px; margin-bottom: 8px;
            background: rgba(255,255,255,0.015); border: 1px solid var(--border);
            font-size: 11px;
        }
        .crystal-item .content-preview {
            color: var(--text); margin-bottom: 4px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .crystal-item .crystal-meta {
            display: flex; gap: 12px; font-size: 10px; color: var(--text-dim);
            font-family: var(--mono);
        }

        .tags-cloud {
            display: flex; flex-wrap: wrap; gap: 6px; margin-top: 12px;
        }
        .tag-pill {
            padding: 3px 10px; border-radius: 12px; font-size: 10px;
            font-family: var(--mono); border: 1px solid var(--border);
            color: var(--text-dim); background: var(--surface);
        }

        /* ── Grid bottom half ── */
        .grid-2 { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        @media (max-width: 900px) { .grid-2 { grid-template-columns: 1fr; } }

        /* ── Footer ── */
        .footer {
            text-align: center; padding: 32px 0 24px;
            font-family: var(--mono); font-size: 10px; color: var(--text-dim);
            border-top: 1px solid var(--border); margin-top: 16px;
        }
        .footer a { color: var(--purple); text-decoration: none; }

        /* ── Empty state ── */
        .empty-state {
            text-align: center; padding: 40px 20px; color: var(--text-dim);
            font-size: 12px;
        }
        .empty-state .icon { font-size: 32px; margin-bottom: 8px; opacity: 0.5; }

        /* ── Loading shimmer ── */
        .shimmer {
            background: linear-gradient(90deg, var(--surface) 25%, rgba(255,255,255,0.04) 50%, var(--surface) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }

        /* ── Prompt / Query Area ── */
        .prompt-section { margin-bottom: 24px; }
        .prompt-card {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: var(--radius); padding: 20px;
        }
        .prompt-input-row {
            display: flex; gap: 10px; margin-top: 12px;
        }
        .prompt-input {
            flex: 1; background: rgba(0,0,0,0.3); border: 1px solid var(--border);
            border-radius: 8px; padding: 10px 14px; color: var(--text-bright);
            font-family: var(--body); font-size: 13px; outline: none;
            transition: border-color 0.2s;
        }
        .prompt-input:focus { border-color: var(--purple); }
        .prompt-input::placeholder { color: var(--text-dim); }
        .prompt-btn {
            padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer;
            font-family: var(--display); font-weight: 600; font-size: 12px;
            letter-spacing: 2px; text-transform: uppercase; transition: all 0.2s;
            background: linear-gradient(135deg, var(--purple), #7c3aed);
            color: white;
        }
        .prompt-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 20px rgba(167,139,250,0.3); }
        .prompt-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        .prompt-btn.routing { background: linear-gradient(135deg, var(--cyan), #0891b2); }

        .query-result {
            margin-top: 16px; display: none;
        }
        .query-result.visible { display: block; animation: fadeSlideIn 0.3s ease; }
        .result-routing {
            display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 12px;
            padding: 12px; border-radius: 8px;
            background: rgba(0,0,0,0.2); border: 1px solid var(--border);
        }
        .result-routing .route-tag {
            display: flex; align-items: center; gap: 6px;
            font-family: var(--mono); font-size: 11px;
        }
        .result-routing .route-tag .label { color: var(--text-dim); }
        .result-routing .route-tag .val { color: var(--text-bright); }
        .result-routing .route-tag .val.model { color: var(--cyan); font-weight: 600; }
        .result-routing .route-tag .val.conf { color: var(--green); }
        .result-routing .route-tag .val.method { color: var(--purple); }
        .dim-bars {
            display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px;
        }
        .dim-bar {
            display: flex; align-items: center; gap: 4px;
            font-family: var(--mono); font-size: 9px;
        }
        .dim-bar .bar-bg {
            width: 40px; height: 4px; border-radius: 2px;
            background: rgba(255,255,255,0.04); overflow: hidden;
        }
        .dim-bar .bar-fill { height: 100%; border-radius: 2px; background: var(--cyan); }
        .result-response {
            padding: 14px; border-radius: 8px;
            background: rgba(0,0,0,0.2); border: 1px solid var(--border);
            font-size: 13px; line-height: 1.6; white-space: pre-wrap;
            max-height: 300px; overflow-y: auto;
        }
        .result-response::-webkit-scrollbar { width: 3px; }
        .result-response::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 4px; }
        .result-timing {
            margin-top: 8px; font-family: var(--mono); font-size: 10px; color: var(--text-dim);
            text-align: right;
        }
        .scores-grid {
            display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px;
        }
        .score-chip {
            padding: 2px 8px; border-radius: 6px; font-family: var(--mono); font-size: 10px;
            background: var(--surface); border: 1px solid var(--border);
        }
        .score-chip.winner { border-color: var(--cyan); color: var(--cyan); background: var(--cyan-dim); }

        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner {
            display: inline-block; width: 14px; height: 14px;
            border: 2px solid rgba(255,255,255,0.1); border-top-color: var(--purple);
            border-radius: 50%; animation: spin 0.6s linear infinite;
            vertical-align: middle; margin-right: 6px;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <div class="ambient"></div>

    <!-- Top Bar -->
    <header class="topbar">
        <div class="topbar-brand">FARNS MESH v2.0</div>
        <nav class="topbar-nav">
            <a href="/">HOME</a>
            <a href="/pro">PRO</a>
            <a href="/mesh" class="active">MESH</a>
            <a href="/health">HEALTH</a>
        </nav>
        <div class="topbar-status">
            <div class="status-pill" id="connStatus">
                <span class="dot"></span>
                <span id="connLabel">CONNECTING</span>
            </div>
            <span style="font-family:var(--mono);font-size:10px;color:var(--text-dim)" id="lastUpdate">--</span>
        </div>
    </header>

    <main class="page">

        <!-- ═══ MESH TOPOLOGY ═══ -->
        <section class="mesh-hero">
            <div class="mesh-hero-header">
                <h2>MESH TOPOLOGY</h2>
                <div class="mesh-meta">
                    <span>ROOT <span class="val" id="meshRoot">--------</span></span>
                    <span>SEQ <span class="val" id="meshSeq">0</span></span>
                    <span>PEERS <span class="val" id="meshPeers">0</span></span>
                    <span>PROTOCOL <span class="val">v2.0.0</span></span>
                </div>
            </div>
            <canvas id="meshCanvas"></canvas>
        </section>

        <!-- ═══ MESH QUERY — Interactive Prompt ═══ -->
        <section class="prompt-section">
            <div class="prompt-card">
                <div class="section-head">
                    <div class="icon" style="background:linear-gradient(135deg,var(--purple-dim),var(--cyan-dim));color:var(--purple);">Q</div>
                    <h2>MESH QUERY</h2>
                    <span class="count" id="queryStatus">READY</span>
                </div>
                <div style="font-size:12px;color:var(--text-dim);margin-bottom:4px;">
                    Send a prompt through the FARNS mesh — latent routes to the best model, runs inference, returns result with full routing metadata.
                </div>
                <div class="prompt-input-row">
                    <input type="text" class="prompt-input" id="queryInput" placeholder="Ask anything — e.g. &quot;Write a Python quicksort&quot; or &quot;Translate hello to Japanese&quot;" autocomplete="off">
                    <button class="prompt-btn" id="queryBtn" onclick="sendMeshQuery()">ROUTE &amp; INFER</button>
                </div>
                <div class="query-result" id="queryResult">
                    <div class="result-routing" id="resultRouting"></div>
                    <div class="dim-bars" id="resultDims"></div>
                    <div class="scores-grid" id="resultScores"></div>
                    <div class="result-response" id="resultResponse"></div>
                    <div class="result-timing" id="resultTiming"></div>
                </div>
            </div>
        </section>

        <!-- ═══ 3-COLUMN: Router / PoI / Attestation ═══ -->
        <div class="grid-3">

            <!-- LATENT SPACE ROUTER -->
            <section class="card">
                <div class="section-head">
                    <div class="icon" style="background:var(--cyan-dim);color:var(--cyan);">R</div>
                    <h2>LATENT ROUTER</h2>
                    <span class="count" id="routeCount">0 routes</span>
                </div>

                <div class="stats-row">
                    <div class="stat-box">
                        <div class="num" id="totalRoutes">0</div>
                        <div class="label">Total</div>
                    </div>
                    <div class="stat-box">
                        <div class="num" id="avgConf">0.0</div>
                        <div class="label">Avg Conf</div>
                    </div>
                    <div class="stat-box">
                        <div class="num" id="routeMethod">--</div>
                        <div class="label">Method</div>
                    </div>
                </div>

                <div class="radar-wrap">
                    <canvas id="radarCanvas" width="280" height="280"></canvas>
                </div>

                <!-- Model heatmap -->
                <div style="margin-top:8px;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:6px;">MODEL STRENGTH MATRIX</div>
                    <div class="heatmap" id="heatmapGrid"></div>
                </div>

                <!-- Route feed -->
                <div style="margin-top:14px;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:6px;">RECENT ROUTES</div>
                    <div class="route-feed" id="routeFeed"></div>
                </div>
            </section>

            <!-- PROOF-OF-INFERENCE -->
            <section class="card">
                <div class="section-head">
                    <div class="icon" style="background:var(--green-dim);color:var(--green);">P</div>
                    <h2>PROOF OF INFERENCE</h2>
                    <span class="count" id="poiCount">0 proofs</span>
                </div>

                <div class="stats-row">
                    <div class="stat-box">
                        <div class="num" id="activeRounds">0</div>
                        <div class="label">Active</div>
                    </div>
                    <div class="stat-box">
                        <div class="num" id="completedProofs">0</div>
                        <div class="label">Verified</div>
                    </div>
                    <div class="stat-box">
                        <div class="num" id="bftThreshold">2/3</div>
                        <div class="label">BFT</div>
                    </div>
                </div>

                <div style="margin-top:16px;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">CONSENSUS ROUNDS</div>
                    <div id="poiRounds">
                        <div class="empty-state">
                            <div class="icon">&#9878;</div>
                            <div>No active rounds</div>
                        </div>
                    </div>
                </div>

                <div style="margin-top:16px;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">VERIFIED PROOFS</div>
                    <div class="proof-list" id="proofList">
                        <div class="empty-state">
                            <div class="icon">&#9883;</div>
                            <div>Awaiting inference consensus</div>
                        </div>
                    </div>
                </div>

                <!-- BFT visualization -->
                <div style="margin-top:16px;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">BFT CONSENSUS</div>
                    <canvas id="bftCanvas" width="280" height="100" style="width:100%;height:100px;"></canvas>
                </div>
            </section>

            <!-- ATTESTATION CHAIN -->
            <section class="card">
                <div class="section-head">
                    <div class="icon" style="background:var(--purple-dim);color:var(--purple);">A</div>
                    <h2>ATTESTATION CHAIN</h2>
                    <span class="count" id="chainLength">0 seals</span>
                </div>

                <div id="chainIntegrity"></div>

                <div style="margin-top:4px;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">CHAIN SEALS</div>
                    <div class="chain-visual" id="chainVisual">
                        <div class="empty-state">
                            <div class="icon">&#9741;</div>
                            <div>No attestations yet</div>
                        </div>
                    </div>
                </div>

                <div class="trust-scores" id="trustSection" style="display:none;">
                    <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">TRUST SCORES</div>
                    <div id="trustList"></div>
                </div>
            </section>
        </div>

        <!-- ═══ SWARM MEMORY CRYSTALS ═══ -->
        <section class="crystals-section">
            <div class="card">
                <div class="section-head">
                    <div class="icon" style="background:linear-gradient(135deg,var(--purple-dim),var(--cyan-dim));color:var(--pink);">M</div>
                    <h2>SWARM MEMORY CRYSTALS</h2>
                    <span class="count" id="crystalCount">0 crystals</span>
                </div>

                <div class="crystal-grid" id="crystalStats">
                    <div class="crystal-stat proposed">
                        <span class="gem">&#9672;</span>
                        <div class="num" id="crystalProposed">0</div>
                        <div class="label">Proposed</div>
                    </div>
                    <div class="crystal-stat voting">
                        <span class="gem">&#9673;</span>
                        <div class="num" id="crystalVoting">0</div>
                        <div class="label">Voting</div>
                    </div>
                    <div class="crystal-stat crystallized">
                        <span class="gem">&#9830;</span>
                        <div class="num" id="crystalCrystallized">0</div>
                        <div class="label">Crystallized</div>
                    </div>
                    <div class="crystal-stat rejected">
                        <span class="gem">&#9651;</span>
                        <div class="num" id="crystalRejected">0</div>
                        <div class="label">Rejected</div>
                    </div>
                </div>

                <div class="grid-2">
                    <div>
                        <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">
                            KNOWLEDGE GRAPH
                            <span style="margin-left:8px;" id="graphEdges">0 edges</span>
                        </div>
                        <canvas id="crystalGraphCanvas" width="600" height="200" style="width:100%;height:200px;border-radius:8px;background:rgba(0,0,0,0.2);"></canvas>
                    </div>
                    <div>
                        <div style="font-family:var(--mono);font-size:10px;color:var(--text-dim);margin-bottom:8px;">TAGS</div>
                        <div class="tags-cloud" id="tagCloud"></div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        FARNS v2.0.0 &mdash; GPU-as-Identity Mesh Protocol &mdash;
        <a href="https://ai.farnsworth.cloud">ai.farnsworth.cloud</a>
    </footer>

    <script>
    // ════════════════════════════════════════════════════════════
    // FARNS MESH DASHBOARD — Pure Vanilla JS
    // ════════════════════════════════════════════════════════════

    const API = '/api/mesh/status';
    let meshData = null;
    let prevData = null;
    let frameId = null;

    // ── Mesh Topology Canvas ──────────────────────────────────
    const meshCanvas = document.getElementById('meshCanvas');
    const meshCtx = meshCanvas.getContext('2d');
    let particles = [];
    let nodes = [];

    function resizeMeshCanvas() {
        const r = meshCanvas.parentElement.getBoundingClientRect();
        meshCanvas.width = r.width * devicePixelRatio;
        meshCanvas.height = 340 * devicePixelRatio;
        meshCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
        meshCanvas.style.height = '340px';
    }
    resizeMeshCanvas();
    window.addEventListener('resize', resizeMeshCanvas);

    class Particle {
        constructor(x1, y1, x2, y2, color) {
            this.x1 = x1; this.y1 = y1;
            this.x2 = x2; this.y2 = y2;
            this.color = color;
            this.t = Math.random();
            this.speed = 0.003 + Math.random() * 0.004;
        }
        update() {
            this.t += this.speed;
            if (this.t > 1) this.t = 0;
        }
        draw(ctx) {
            const x = this.x1 + (this.x2 - this.x1) * this.t;
            const y = this.y1 + (this.y2 - this.y1) * this.t;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            // Glow
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fillStyle = this.color.replace(')', ',0.2)').replace('rgb', 'rgba');
            ctx.fill();
        }
    }

    function buildMeshNodes(data) {
        const w = meshCanvas.width / devicePixelRatio;
        const h = 340;
        const cx = w / 2, cy = h / 2;
        nodes = [];
        particles = [];

        // Primary node (us)
        const primary = {
            name: data.node_name || 'unknown',
            x: cx - 180, y: cy,
            color: '#a78bfa',
            gpu: data.gpu_fingerprint || '---',
            identity: data.identity || '---',
            bots: data.local_bots || [],
            isPrimary: true,
        };
        nodes.push(primary);

        // Peer nodes
        const peers = data.connected_peers || [];
        peers.forEach((peerName, i) => {
            const angle = -0.3 + (i * 0.6 / Math.max(peers.length - 1, 1));
            const node = {
                name: peerName,
                x: cx + 180, y: cy + (i - (peers.length - 1) / 2) * 100,
                color: '#22d3ee',
                gpu: '---',
                identity: '---',
                bots: [],
                isPrimary: false,
            };
            nodes.push(node);

            // Particles between nodes
            for (let p = 0; p < 8; p++) {
                particles.push(new Particle(primary.x, primary.y, node.x, node.y, 'rgba(167,139,250,0.6)'));
                particles.push(new Particle(node.x, node.y, primary.x, primary.y, 'rgba(34,211,238,0.6)'));
            }
        });

        // If no peers, show isolated node
        if (peers.length === 0) {
            // Add ghost peer for visual
            const ghost = {
                name: '(awaiting peer)',
                x: cx + 180, y: cy,
                color: 'rgba(255,255,255,0.1)',
                gpu: '', identity: '', bots: [],
                isPrimary: false, isGhost: true,
            };
            nodes.push(ghost);
        }
    }

    function drawMeshTopology() {
        const w = meshCanvas.width / devicePixelRatio;
        const h = 340;
        meshCtx.clearRect(0, 0, w, h);

        // Draw connection lines
        if (nodes.length > 1) {
            for (let i = 1; i < nodes.length; i++) {
                const n0 = nodes[0], n1 = nodes[i];
                meshCtx.beginPath();
                meshCtx.moveTo(n0.x, n0.y);
                // Curved line
                const cpx = (n0.x + n1.x) / 2;
                const cpy = (n0.y + n1.y) / 2 - 20;
                meshCtx.quadraticCurveTo(cpx, cpy, n1.x, n1.y);
                meshCtx.strokeStyle = n1.isGhost ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.06)';
                meshCtx.lineWidth = n1.isGhost ? 1 : 1.5;
                meshCtx.setLineDash(n1.isGhost ? [4, 4] : []);
                meshCtx.stroke();
                meshCtx.setLineDash([]);
            }
        }

        // Draw particles
        particles.forEach(p => {
            p.update();
            p.draw(meshCtx);
        });

        // Draw nodes
        nodes.forEach(n => {
            // Outer glow
            if (!n.isGhost) {
                const grad = meshCtx.createRadialGradient(n.x, n.y, 0, n.x, n.y, 50);
                grad.addColorStop(0, n.color.replace(')', ',0.12)').replace('#', 'rgba(').replace(/rgba\(([^)]+)\)/, (_, c) => {
                    // Convert hex to rgba
                    return n.isPrimary ? 'rgba(167,139,250,0.12)' : 'rgba(34,211,238,0.12)';
                }));
                grad.addColorStop(1, 'transparent');
                meshCtx.fillStyle = n.isPrimary ? 'rgba(167,139,250,0.08)' : 'rgba(34,211,238,0.08)';
                meshCtx.beginPath();
                meshCtx.arc(n.x, n.y, 45, 0, Math.PI * 2);
                meshCtx.fill();
            }

            // Node circle
            meshCtx.beginPath();
            meshCtx.arc(n.x, n.y, 24, 0, Math.PI * 2);
            meshCtx.fillStyle = n.isGhost ? 'rgba(255,255,255,0.02)' : (n.isPrimary ? 'rgba(167,139,250,0.15)' : 'rgba(34,211,238,0.15)');
            meshCtx.fill();
            meshCtx.strokeStyle = n.isGhost ? 'rgba(255,255,255,0.06)' : (n.isPrimary ? '#a78bfa' : '#22d3ee');
            meshCtx.lineWidth = n.isGhost ? 0.5 : 1.5;
            meshCtx.stroke();

            // Inner dot
            if (!n.isGhost) {
                meshCtx.beginPath();
                meshCtx.arc(n.x, n.y, 4, 0, Math.PI * 2);
                meshCtx.fillStyle = n.isPrimary ? '#a78bfa' : '#22d3ee';
                meshCtx.fill();
            }

            // Labels
            meshCtx.font = '600 11px "Chakra Petch", sans-serif';
            meshCtx.textAlign = 'center';
            meshCtx.fillStyle = n.isGhost ? 'rgba(255,255,255,0.15)' : '#e8ecf4';
            meshCtx.fillText(n.name, n.x, n.y + 42);

            if (!n.isGhost) {
                meshCtx.font = '10px "JetBrains Mono", monospace';
                meshCtx.fillStyle = 'rgba(255,255,255,0.3)';
                meshCtx.fillText(n.identity.slice(0, 12) + '...', n.x, n.y + 56);
                meshCtx.fillStyle = n.isPrimary ? 'rgba(167,139,250,0.5)' : 'rgba(34,211,238,0.5)';
                meshCtx.fillText(n.bots.length + ' bots', n.x, n.y - 34);
            }
        });
    }

    function animateMesh() {
        drawMeshTopology();
        frameId = requestAnimationFrame(animateMesh);
    }
    animateMesh();

    // ── Radar Chart ───────────────────────────────────────────
    const radarCanvas = document.getElementById('radarCanvas');
    const radarCtx = radarCanvas.getContext('2d');
    const DIMS = ['code', 'math', 'reasoning', 'creative', 'factual', 'multilingual'];
    const MODEL_COLORS = {
        'qwen3-coder-next-latest': '#a78bfa',
        'phi4-latest': '#f472b6',
        'deepseek-r1-8b': '#22d3ee',
        'qwen2.5-7b': '#fbbf24',
        'mistral-7b': '#f87171',
        'llama3-8b': '#34d399',
        'gemma2-9b': '#fb923c',
    };

    function drawRadar(models) {
        const w = 280, h = 280, cx = w/2, cy = h/2, r = 100;
        radarCtx.clearRect(0, 0, w, h);

        // Grid rings
        for (let ring = 1; ring <= 4; ring++) {
            const rr = (r / 4) * ring;
            radarCtx.beginPath();
            for (let i = 0; i <= 6; i++) {
                const a = (Math.PI * 2 / 6) * i - Math.PI / 2;
                const px = cx + Math.cos(a) * rr;
                const py = cy + Math.sin(a) * rr;
                i === 0 ? radarCtx.moveTo(px, py) : radarCtx.lineTo(px, py);
            }
            radarCtx.closePath();
            radarCtx.strokeStyle = 'rgba(255,255,255,0.04)';
            radarCtx.lineWidth = 1;
            radarCtx.stroke();
        }

        // Axis lines + labels
        DIMS.forEach((dim, i) => {
            const a = (Math.PI * 2 / 6) * i - Math.PI / 2;
            const px = cx + Math.cos(a) * r;
            const py = cy + Math.sin(a) * r;
            radarCtx.beginPath();
            radarCtx.moveTo(cx, cy);
            radarCtx.lineTo(px, py);
            radarCtx.strokeStyle = 'rgba(255,255,255,0.04)';
            radarCtx.stroke();

            // Label
            const lx = cx + Math.cos(a) * (r + 16);
            const ly = cy + Math.sin(a) * (r + 16);
            radarCtx.font = '9px "JetBrains Mono", monospace';
            radarCtx.textAlign = 'center';
            radarCtx.textBaseline = 'middle';
            radarCtx.fillStyle = 'rgba(255,255,255,0.3)';
            radarCtx.fillText(dim.toUpperCase(), lx, ly);
        });

        // Draw each model
        if (!models) return;
        const modelNames = Object.keys(models);
        modelNames.forEach((name, mi) => {
            const m = models[name];
            const strengths = m.strengths || {};
            const color = MODEL_COLORS[name] || `hsl(${mi * 51}, 70%, 65%)`;

            radarCtx.beginPath();
            DIMS.forEach((dim, i) => {
                const val = strengths[dim] || 0;
                const a = (Math.PI * 2 / 6) * i - Math.PI / 2;
                const px = cx + Math.cos(a) * r * val;
                const py = cy + Math.sin(a) * r * val;
                i === 0 ? radarCtx.moveTo(px, py) : radarCtx.lineTo(px, py);
            });
            radarCtx.closePath();
            radarCtx.fillStyle = color.replace(')', ',0.06)').replace('rgb', 'rgba').replace(/#[0-9a-f]{6}/i, color + '0f');
            radarCtx.strokeStyle = color;
            radarCtx.lineWidth = 1.5;
            radarCtx.globalAlpha = 0.7;
            radarCtx.stroke();
            radarCtx.globalAlpha = 0.08;
            radarCtx.fill();
            radarCtx.globalAlpha = 1;
        });
    }

    // ── Heatmap ───────────────────────────────────────────────
    function drawHeatmap(models) {
        const grid = document.getElementById('heatmapGrid');
        grid.innerHTML = '';

        // Header row (dimensions)
        const blank = document.createElement('div');
        blank.className = 'heatmap-label';
        blank.textContent = '';
        grid.appendChild(blank);
        DIMS.forEach(d => {
            const lbl = document.createElement('div');
            lbl.className = 'heatmap-label';
            lbl.textContent = d.slice(0, 4).toUpperCase();
            grid.appendChild(lbl);
        });

        if (!models) return;
        Object.keys(models).forEach(name => {
            const m = models[name];
            const s = m.strengths || {};

            // Row label
            const rlbl = document.createElement('div');
            rlbl.className = 'heatmap-label';
            rlbl.textContent = name.split('-')[0].slice(0, 6);
            rlbl.style.textAlign = 'right';
            grid.appendChild(rlbl);

            DIMS.forEach(dim => {
                const val = s[dim] || 0;
                const cell = document.createElement('div');
                cell.className = 'heatmap-cell';
                // Color interpolation: low=dark, high=bright
                const h = val > 0.7 ? 140 : val > 0.5 ? 200 : val > 0.3 ? 260 : 0;
                const l = 15 + val * 30;
                cell.style.background = `hsla(${h}, 60%, ${l}%, 0.6)`;
                cell.textContent = val.toFixed(1);
                cell.title = `${name} — ${dim}: ${val.toFixed(2)}`;
                grid.appendChild(cell);
            });
        });

        // Update grid columns
        grid.style.gridTemplateColumns = `60px repeat(${DIMS.length}, 1fr)`;
    }

    // ── Route Feed ────────────────────────────────────────────
    function updateRouteFeed(routes) {
        const feed = document.getElementById('routeFeed');
        if (!routes || routes.length === 0) {
            feed.innerHTML = '<div class="empty-state" style="padding:16px;"><div style="font-size:20px;opacity:0.3;">&#8644;</div><div>No routes yet</div></div>';
            return;
        }
        feed.innerHTML = '';
        routes.slice().reverse().forEach(r => {
            const item = document.createElement('div');
            item.className = 'route-item';
            const confColor = r.confidence > 0.8 ? 'var(--green)' : r.confidence > 0.6 ? 'var(--amber)' : 'var(--red)';
            const confBg = r.confidence > 0.8 ? 'var(--green-dim)' : r.confidence > 0.6 ? 'var(--amber-dim)' : 'var(--red-dim)';
            item.innerHTML = `
                <span class="prompt">${escHtml(r.prompt || '...')}</span>
                <span class="arrow">&#8594;</span>
                <span class="model">${r.model || '?'}</span>
                <span class="conf" style="color:${confColor};background:${confBg}">${(r.confidence || 0).toFixed(2)}</span>
            `;
            feed.appendChild(item);
        });
    }

    // ── BFT Canvas ────────────────────────────────────────────
    const bftCanvas = document.getElementById('bftCanvas');
    const bftCtx = bftCanvas.getContext('2d');

    function drawBFT(activeRounds, completedProofs) {
        const w = bftCanvas.width, h = bftCanvas.height;
        bftCtx.clearRect(0, 0, w, h);

        // Draw validator nodes in a circle
        const total = 3; // BFT with 3 validators
        const cx = w / 2, cy = h / 2, r = 35;

        for (let i = 0; i < total; i++) {
            const a = (Math.PI * 2 / total) * i - Math.PI / 2;
            const x = cx + Math.cos(a) * r;
            const y = cy + Math.sin(a) * r;

            // Node
            bftCtx.beginPath();
            bftCtx.arc(x, y, 12, 0, Math.PI * 2);
            const agreed = i < 2; // 2/3 agree
            bftCtx.fillStyle = agreed ? 'rgba(52,211,153,0.15)' : 'rgba(248,113,113,0.1)';
            bftCtx.fill();
            bftCtx.strokeStyle = agreed ? '#34d399' : '#f87171';
            bftCtx.lineWidth = 1.5;
            bftCtx.stroke();

            // Label
            bftCtx.font = '9px "JetBrains Mono"';
            bftCtx.textAlign = 'center';
            bftCtx.fillStyle = agreed ? '#34d399' : '#f87171';
            bftCtx.fillText(agreed ? 'AGR' : 'DIS', x, y + 3);

            // Connection to center
            bftCtx.beginPath();
            bftCtx.moveTo(cx, cy);
            bftCtx.lineTo(x, y);
            bftCtx.strokeStyle = 'rgba(255,255,255,0.04)';
            bftCtx.lineWidth = 0.5;
            bftCtx.stroke();
        }

        // Center — consensus result
        bftCtx.beginPath();
        bftCtx.arc(cx, cy, 8, 0, Math.PI * 2);
        bftCtx.fillStyle = 'rgba(52,211,153,0.2)';
        bftCtx.fill();

        // Label
        bftCtx.font = '600 10px "Chakra Petch"';
        bftCtx.fillStyle = '#e8ecf4';
        bftCtx.fillText('2/3+ CONSENSUS', cx, cy + r + 24);
        bftCtx.font = '9px "JetBrains Mono"';
        bftCtx.fillStyle = 'rgba(255,255,255,0.3)';
        bftCtx.fillText(`${completedProofs || 0} verified`, cx, cy + r + 38);
    }

    // ── Crystal Graph Canvas ──────────────────────────────────
    const crystalCanvas = document.getElementById('crystalGraphCanvas');
    const crystalCtx = crystalCanvas.getContext('2d');

    function drawCrystalGraph(memData) {
        const w = crystalCanvas.width, h = crystalCanvas.height;
        crystalCtx.clearRect(0, 0, w, h);

        const total = memData?.total_crystals || 0;
        const edges = memData?.graph_edges || 0;

        if (total === 0) {
            crystalCtx.font = '11px "DM Sans"';
            crystalCtx.fillStyle = 'rgba(255,255,255,0.15)';
            crystalCtx.textAlign = 'center';
            crystalCtx.fillText('Awaiting crystal formation...', w/2, h/2);
            return;
        }

        // Generate pseudo-crystal nodes
        const crystalNodes = [];
        const count = Math.min(total, 30);
        for (let i = 0; i < count; i++) {
            crystalNodes.push({
                x: 40 + Math.random() * (w - 80),
                y: 20 + Math.random() * (h - 40),
                r: 3 + Math.random() * 4,
                status: ['crystallized', 'proposed', 'voting'][Math.floor(Math.random() * 3)],
            });
        }

        // Draw edges
        const edgeCount = Math.min(edges, count * 2);
        for (let e = 0; e < edgeCount; e++) {
            const a = crystalNodes[Math.floor(Math.random() * count)];
            const b = crystalNodes[Math.floor(Math.random() * count)];
            if (a === b) continue;
            crystalCtx.beginPath();
            crystalCtx.moveTo(a.x, a.y);
            crystalCtx.lineTo(b.x, b.y);
            crystalCtx.strokeStyle = 'rgba(255,255,255,0.03)';
            crystalCtx.lineWidth = 0.5;
            crystalCtx.stroke();
        }

        // Draw crystal nodes
        crystalNodes.forEach(n => {
            const color = n.status === 'crystallized' ? '#34d399' :
                          n.status === 'voting' ? '#22d3ee' : '#fbbf24';
            crystalCtx.beginPath();
            // Diamond shape for crystals
            crystalCtx.moveTo(n.x, n.y - n.r);
            crystalCtx.lineTo(n.x + n.r * 0.7, n.y);
            crystalCtx.lineTo(n.x, n.y + n.r);
            crystalCtx.lineTo(n.x - n.r * 0.7, n.y);
            crystalCtx.closePath();
            crystalCtx.fillStyle = color.replace(')', ',0.3)').replace('rgb', 'rgba');
            crystalCtx.fillStyle = color + '20';
            crystalCtx.fill();
            crystalCtx.strokeStyle = color + '80';
            crystalCtx.lineWidth = 1;
            crystalCtx.stroke();
        });
    }

    // ── Data Update ───────────────────────────────────────────
    function escHtml(s) {
        const d = document.createElement('div');
        d.textContent = s;
        return d.innerHTML;
    }

    function updateDashboard(data) {
        if (!data) return;
        prevData = meshData;
        meshData = data;

        // Connection status
        const connPill = document.getElementById('connStatus');
        const connLabel = document.getElementById('connLabel');
        if (data.peer_count > 0) {
            connPill.classList.remove('offline');
            connLabel.textContent = `${data.peer_count} PEER${data.peer_count > 1 ? 'S' : ''}`;
        } else {
            connPill.classList.add('offline');
            connLabel.textContent = 'NO PEERS';
        }
        document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();

        // Mesh meta
        document.getElementById('meshRoot').textContent = data.mesh_root || '--------';
        document.getElementById('meshSeq').textContent = data.mesh_sequence || 0;
        document.getElementById('meshPeers').textContent = data.mesh_peers || 0;

        // Build topology only when peers change (preserves particle animation)
        const newPeerKey = JSON.stringify(data.connected_peers || []);
        const oldPeerKey = prevData ? JSON.stringify(prevData.connected_peers || []) : '';
        if (newPeerKey !== oldPeerKey || nodes.length === 0) {
            buildMeshNodes(data);
        }

        // ── Latent Router ──
        const lr = data.latent_router || {};
        document.getElementById('routeCount').textContent = `${lr.total_routes || 0} routes`;
        document.getElementById('totalRoutes').textContent = lr.total_routes || 0;
        document.getElementById('avgConf').textContent = (lr.avg_confidence || 0).toFixed(2);

        const methods = lr.methods || {};
        const topMethod = Object.keys(methods).sort((a, b) => methods[b] - methods[a])[0] || '--';
        document.getElementById('routeMethod').textContent = topMethod;

        drawRadar(lr.models);
        drawHeatmap(lr.models);
        updateRouteFeed(lr.recent_routes);

        // ── Proof-of-Inference ──
        const poi = data.poi || {};
        document.getElementById('activeRounds').textContent = poi.active_rounds || 0;
        document.getElementById('completedProofs').textContent = poi.completed_proofs || 0;
        document.getElementById('poiCount').textContent = `${poi.completed_proofs || 0} proofs`;
        drawBFT(poi.active_rounds, poi.completed_proofs);

        // ── Attestation Chain ──
        const att = data.attestation || {};
        const chainLen = att.chain_length || 0;
        document.getElementById('chainLength').textContent = `${chainLen} seals`;

        // Integrity badge
        const integ = document.getElementById('chainIntegrity');
        if (chainLen > 0) {
            integ.innerHTML = `<span class="integrity-badge valid">&#10003; CHAIN INTACT &mdash; ${chainLen} seals</span>`;
        } else {
            integ.innerHTML = `<span class="integrity-badge broken">&#9888; NO CHAIN</span>`;
        }

        // Chain visualization
        const chainVis = document.getElementById('chainVisual');
        const models_attested = att.models_attested || [];
        if (models_attested.length > 0) {
            chainVis.innerHTML = '';
            models_attested.slice(-6).forEach((model, i) => {
                const link = document.createElement('div');
                link.className = 'chain-link';
                link.innerHTML = `
                    <div class="seal">${att.last_seal || '0'.repeat(32)}</div>
                    <div class="meta">
                        <span>${escHtml(model)}</span>
                        <span>gpu:${(att.gpu_model || 'unknown').slice(0, 20)}</span>
                        <span>seq:${chainLen - models_attested.length + i + 1}</span>
                    </div>
                `;
                chainVis.appendChild(link);
            });
        }

        // Trust scores
        const trust = att.trust_scores || {};
        const trustKeys = Object.keys(trust);
        const trustSection = document.getElementById('trustSection');
        const trustList = document.getElementById('trustList');
        if (trustKeys.length > 0) {
            trustSection.style.display = 'block';
            trustList.innerHTML = '';
            trustKeys.forEach(node => {
                const score = trust[node];
                const row = document.createElement('div');
                row.className = 'trust-row';
                row.innerHTML = `
                    <span class="node-name">${escHtml(node)}</span>
                    <div class="trust-bar-bg"><div class="trust-bar-fill" style="width:${score * 100}%"></div></div>
                    <span class="trust-score">${score.toFixed(3)}</span>
                `;
                trustList.appendChild(row);
            });
        }

        // ── Swarm Memory ──
        const mem = data.swarm_memory || {};
        document.getElementById('crystalCount').textContent = `${mem.total_crystals || 0} crystals`;
        const byStatus = mem.by_status || {};
        document.getElementById('crystalProposed').textContent = byStatus.proposed || 0;
        document.getElementById('crystalVoting').textContent = byStatus.voting || 0;
        document.getElementById('crystalCrystallized').textContent = byStatus.crystallized || 0;
        document.getElementById('crystalRejected').textContent = byStatus.rejected || 0;
        document.getElementById('graphEdges').textContent = `${mem.graph_edges || 0} edges`;

        drawCrystalGraph(mem);

        // Tags cloud
        const tagCloud = document.getElementById('tagCloud');
        const tags = mem.unique_tags || [];
        tagCloud.innerHTML = '';
        tags.forEach(tag => {
            const pill = document.createElement('span');
            pill.className = 'tag-pill';
            pill.textContent = tag;
            tagCloud.appendChild(pill);
        });
    }

    // ── Polling ───────────────────────────────────────────────
    async function fetchStatus() {
        try {
            const resp = await fetch(API);
            if (!resp.ok) throw new Error(resp.status);
            const data = await resp.json();
            updateDashboard(data);
        } catch (e) {
            // Show offline status
            const connPill = document.getElementById('connStatus');
            connPill.classList.add('offline');
            document.getElementById('connLabel').textContent = 'OFFLINE';
        }
    }

    // Initial fetch + poll every 3s
    fetchStatus();
    setInterval(fetchStatus, 3000);

    // ── Canvas DPI fix for radar + crystal ──
    function fixCanvasDPI(canvas) {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * devicePixelRatio;
        canvas.height = rect.height * devicePixelRatio;
        const ctx = canvas.getContext('2d');
        ctx.scale(devicePixelRatio, devicePixelRatio);
    }
    // Fix on load
    setTimeout(() => {
        [bftCanvas, crystalCanvas].forEach(fixCanvasDPI);
        if (meshData) {
            drawBFT(meshData.poi?.active_rounds, meshData.poi?.completed_proofs);
            drawCrystalGraph(meshData.swarm_memory);
        }
    }, 100);
    // ── Mesh Query (Interactive Prompt) ──────────────────────
    const queryInput = document.getElementById('queryInput');
    const queryBtn = document.getElementById('queryBtn');
    const queryResult = document.getElementById('queryResult');
    const queryStatus = document.getElementById('queryStatus');

    queryInput.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !queryBtn.disabled) sendMeshQuery();
    });

    async function sendMeshQuery() {
        const prompt = queryInput.value.trim();
        if (!prompt) return;

        // UI: loading state
        queryBtn.disabled = true;
        queryBtn.classList.add('routing');
        queryBtn.innerHTML = '<span class="spinner"></span>ROUTING...';
        queryStatus.textContent = 'ROUTING';
        queryResult.classList.remove('visible');

        try {
            const resp = await fetch('/api/mesh/query', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt }),
            });
            const data = await resp.json();

            if (data.error) {
                showQueryError(data.error);
                return;
            }

            // Routing metadata
            const routing = document.getElementById('resultRouting');
            routing.innerHTML = `
                <div class="route-tag"><span class="label">ROUTED TO</span> <span class="val model">${escHtml(data.routed_to || '?')}</span></div>
                <div class="route-tag"><span class="label">CONFIDENCE</span> <span class="val conf">${(data.confidence || 0).toFixed(4)}</span></div>
                <div class="route-tag"><span class="label">METHOD</span> <span class="val method">${escHtml(data.method || '?')}</span></div>
                <div class="route-tag"><span class="label">LATENCY</span> <span class="val">${data.inference_ms || 0}ms</span></div>
            `;

            // Dimension bars
            const dims = data.dimensions || {};
            const dimHtml = Object.entries(dims).sort((a,b) => b[1] - a[1]).map(([dim, val]) =>
                `<div class="dim-bar">
                    <span style="color:var(--text-dim);min-width:52px;">${dim}</span>
                    <div class="bar-bg"><div class="bar-fill" style="width:${(val * 100).toFixed(0)}%"></div></div>
                    <span style="color:var(--text-dim)">${val.toFixed(2)}</span>
                </div>`
            ).join('');
            document.getElementById('resultDims').innerHTML = dimHtml;

            // All model scores
            const scores = data.all_scores || {};
            const winner = data.routed_to;
            const scoresHtml = Object.entries(scores).sort((a,b) => b[1] - a[1]).map(([model, score]) =>
                `<span class="score-chip ${model === winner ? 'winner' : ''}">${model.split('-')[0]}:${score.toFixed(3)}</span>`
            ).join('');
            document.getElementById('resultScores').innerHTML = scoresHtml;

            // Response
            const responseDiv = document.getElementById('resultResponse');
            responseDiv.textContent = data.response || '(no response)';

            // Timing
            document.getElementById('resultTiming').textContent =
                `Routed to ${data.routed_to} in ${data.inference_ms}ms via ${data.method} routing`;

            queryResult.classList.add('visible');
            queryStatus.textContent = 'COMPLETE';

        } catch (e) {
            showQueryError('Network error: ' + e.message);
        } finally {
            queryBtn.disabled = false;
            queryBtn.classList.remove('routing');
            queryBtn.innerHTML = 'ROUTE &amp; INFER';
        }
    }

    function showQueryError(msg) {
        const routing = document.getElementById('resultRouting');
        routing.innerHTML = `<div class="route-tag"><span class="label" style="color:var(--red);">ERROR</span> <span class="val" style="color:var(--red);">${escHtml(msg)}</span></div>`;
        document.getElementById('resultDims').innerHTML = '';
        document.getElementById('resultScores').innerHTML = '';
        document.getElementById('resultResponse').textContent = '';
        document.getElementById('resultTiming').textContent = '';
        queryResult.classList.add('visible');
        queryStatus.textContent = 'ERROR';
    }
    </script>
</body>
</html>
